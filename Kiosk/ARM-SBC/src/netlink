#!/bin/sh
# turn on line tracing
# set -x

DNS_DIG=`command -v dig`
if [ -z "$DNS_DIG" ] ; then
	echo "The dig command is required for DNS lookup. Exiting"
	exit -1
fi

# This is the network status file.
# NETLOCK has to be passed from the environment
if [ -z "$NETLOCK" ] ; then
	echo "NETLOCK environment variable is required. Exiting"
	exit -1
fi
# This is the program for talking to the cell modem
CELL_COMS="/BBD9000/BBD9000cell"

NET_STATUS=""
ETH_STATUS=""
PPP_STATUS=""

MAX_REBOOT_RETRIES=2  # Max times to reboot the modem
MAX_CALL_RETRIES=3    # Max pppd calls between modem reboots
MODEM_REBOOTS=0
# When modem will be ready after a modem shutdown
MODEM_SHUTDOWN_READY=`date +%s`
MODEM_STATUS=""
SIG_BARS_STATUS=""
SIG_STATUS=""
SIM_STATUS=""
SMS_STATUS=""

# These respond to ping
PING_NAMES="google.com level3.com opendns.org"
# These are public DNSs: Google, Level 3, OpenDNS (3 primaries, 3 secondaries)
PING_IPs="8.8.8.8 4.2.2.1 208.67.222.222"
PING_IPs2="8.8.4.4 4.2.2.2 208.67.220.220"

# Get HOSTNAME
#. /etc/sysconfig/network_cfg
HOSTNAME=`hostname`
# Get eth0 setup
#. /etc/sysconfig/ifcfg-eth0
# Get the modem device (this has so far been in /dev/tts/, but the # can change based on address)
dev_num=`ls /dev/tts`
MODEM_DEV=""
if [ "$dev_num" != "" ] ; then
	MODEM_DEV="/dev/tts/${dev_num}"

	# Check that the modem device is set correctly in the ppp script and in the conf file.
	has_dev=`grep ${MODEM_DEV} /etc/ppp/peers/embeddedworks`
	if [ "$has_dev" = "" ] ; then
		sed s_/dev/tts/[0-9]_${MODEM_DEV}_ /etc/ppp/peers/embeddedworks > /etc/ppp/peers/embeddedworks~
		mv /etc/ppp/peers/embeddedworks~ /etc/ppp/peers/embeddedworks
		echo "Updated modem device in /etc/ppp/peers/embeddedworks to $MODEM_DEV"
	fi
fi


check_iface_DNS ()
{
	IFACE_ADDRESS=`ifconfig $CHECK_IFACE 2>/dev/null | grep 'inet addr' | cut -d ':' -f 2 | cut -d ' ' -f 1`
	if [ -n "$IFACE_ADDRESS" ] ; then
echo "looking up google.com using $CHECK_IFACE by binding to $IFACE_ADDRESS"
		/usr/bin/dig google.com a in +short +time=2 +tries=2 -b $IFACE_ADDRESS >/dev/null 2>&1
		if [ $? -ne 0 ] ; then
		# no DNS through iface
			IFACE_DNS=""
			return 1
		else
			IFACE_DNS="OK"
			return 0
		fi
	else
		IFACE_DNS=""
		return 0
	fi
}

check_iface_ping ()
{
	# Ping public DNS servers
	# Google DNS servers: 8.8.8.8 and 8.8.4.4.
	# Level 3 DNS servers: 4.2.2.1 and 4.2.2.2
	# OpenDNS DNS servers: 208.67.222.222 and 208.67.220.220
	
	good_IPs=""
	n_good_IPs=0
	for IP in $CHECK_IPs ; do
		bad_ip=""
echo "ping $CHECK_IFACE $IP"
		/bin/ping -W $PING_TIMEOUT -I $CHECK_IFACE -c 1 -n $IP >/dev/null 2>&1
		if [ $? -eq 0 ] ; then
			good_IPs="$good_IPs $IP"
			n_good_IPs=`expr $n_good_IPs + 1`
		fi
		
		if [ $n_good_IPs -ge $PING_MAX_IPS ] ; then
			break
		fi
		
	done
	return $n_good_IPs
}


check_iface_up () 
{
	CHECK_IFACE=$1
	PING_TIMEOUT=$2
	PING_MAX_IPS=1
	IS_IFACE_UP=""
	IFACE_ADDRESS=`ifconfig $CHECK_IFACE 2>/dev/null | grep 'inet addr' | cut -d ':' -f 2 | cut -d ' ' -f 1`
echo "$CHECK_IFACE IFACE_ADDRESS = $IFACE_ADDRESS"

	if [ -n "$IFACE_ADDRESS" ] ; then
		CHECK_IPs=$PING_IPs
		check_iface_ping
		if [ $? -gt 0 ] ; then
		# resolv.conf or servers in it may still not be valid
			check_iface_DNS
			if [ $? -eq 0 ] ; then
				IS_IFACE_UP=1
				IFACE_STATUS="$IFACE_ADDRESS Up"
			else # DNS doesn't work
				IS_IFACE_UP=""
				IFACE_STATUS="$IFACE_ADDRESS DNS-Offline"
			fi
			IFACE_GATEWAY=`/sbin/route -n 2>/dev/null | grep $CHECK_IFACE$ | grep '^0.0.0.0' | tr -s " " | cut -d ' ' -f 2`
echo "$CHECK_IFACE IFACE_GATEWAY = $IFACE_GATEWAY"
		else # no WAN IPs
			IS_IFACE_UP=""
			IFACE_STATUS="$IFACE_ADDRESS No-WAN"
		fi
	else # no iface interface
		IS_IFACE_UP=""
		IFACE_STATUS="No-IP-Addr Offline"
	fi
}


eth0_down () 
{
#
#	/usr/bin/killall udhcpc >/dev/null 2>&1
# Keep the default route for now - delete it before bringing up ppp
#	/sbin/route del default eth0 >/dev/null 2>&1
# Don't actually bring the interface down so we can still connect in.
#	ifconfig ${DEVICE} down
# was resolv.conf generated by udhcpc?
# resolv.conf doesn't get written over by dhcpc unless it confirms WAN access
#	rm /etc/resolv.cof

# Keep udhcpc running in case it acquires a lease
#	/usr/bin/killall udhcpc >/dev/null 2>&1
	echo  "Shut down device eth0"
}

eth0_up () 
{
	# if its still down, then dhcpc might be stuck
	/usr/bin/killall udhcpc >/dev/null 2>&1
	usleep 100000
	eth0_WAN=`/sbin/udhcpc -b -H $HOSTNAME -i eth0 -s /etc/udhcpc/checkping.script 2>/dev/null | grep ^Router | cut -d ' ' -f 8`
	# eth0_WAN=`/sbin/udhcpc -q -H $HOSTNAME -n -i eth0 -s /etc/udhcpc/checkping.script 2> /dev/null | grep ^Router | cut -d ' ' -f 8`
	# udhcpc checks for ping to WAN IPs
	# Router: 10.0.1.1 Domain: cathilya.org DNS: OK WAN: OK
	# Status is either Offline (WAN offline) or Up (WAN OK).
	# If WAN OK, udhcpc added a default route, and rewrote resolv.conf
	ETH_ADDRESS=`ifconfig eth0 2>/dev/null | grep 'inet addr' | cut -d ':' -f 2 | cut -d ' ' -f 1`
	ETH_GATEWAY=`/sbin/route -n 2>/dev/null | grep 'eth0$' | grep '^0.0.0.0' | tr -s " " | cut -d ' ' -f 2`
	if [ "$eth0_WAN" = "OK" ] ; then
		# Check DNS system
		CHECK_IFACE="eth0"
		check_iface_DNS
		if [ $? -eq 0 ] ; then
			IS_ETH_UP=1
			ETH_STATUS="$ETH_ADDRESS Up"
		else # can't resolve google.com
			IS_ETH_UP=""
			if [ -n "$ETH_ADDRESS" ] ; then
				ETH_STATUS="$ETH_ADDRESS DNS-Offline"
			else
				ETH_STATUS="No-IP-Addr Offline"
			fi
		fi
	else
		ETH_STATUS="$ETH_ADDRESS No-WAN"
		IS_ETH_UP=""
	fi
}


ppp_down ()
{

	pppd_pid=`pidof pppd 2>/dev/null`
echo "pppd_pid : $pppd_pid"

	if [ -n "$pppd_pid" ] ; then
		/usr/bin/killall pppd >/dev/null 2>&1
		usleep 100000
		pppd_pid=`pidof pppd 2>/dev/null`
		nRetries=10
		while [ -n "$pppd_pid" -a $nRetries -ge 0 ] ; do
			usleep 100000
			pppd_pid=`pidof pppd 2>/dev/null`
			nRetries=`expr $nRetries - 1`
		done
	fi
	
	if [ -n "$pppd_pid" ] ; then
		/usr/bin/killall -9 pppd >/dev/null 2>&1
		usleep 100000
		pppd_pid=`pidof pppd 2>/dev/null`
		nRetries=5
echo "killall -9 pppd"
		while [ -n "$pppd_pid" -a $nRetries -ge 0 ] ; do
			usleep 100000
			pppd_pid=`pidof pppd 2>/dev/null`
			nRetries=`expr $nRetries - 1`
		done
	fi

	if [ -z "$pppd_pid" ] ; then
		IS_PPP_UP=""
		PPP_STATUS="No-Interface Offline"
	fi

	rm /var/run/ppp0.pid >/dev/null 2>&1
	echo "shut down ppp"
}


get_modem_status ()
{
# This will probably not be able to talk to the modem and return if pppd is running
# Occasionally the SIM is screwy and we need a modem reset just to talk to it.
# The status does not return with an error if there is no SIM
# It does wait to get a valid reception reading, which we don't need a SIM for.
# It will try for about 20 seconds to get a valid signal reading
# Status line:
# -91 dBm (3/5) SIM: None SMS: None
# -91 dBm (3/5) SIM: OK SMS: Checkin

	if [ -z "$MODEM_DEV" ] ; then
		IS_PPP_UP=""
		PPP_STATUS="No-Modem Offline"
		return 1
	fi

# cached modem status may be an issue...
	if [ -n "$MODEM_STATUS" ] ; then
		return 0
	fi
	
	time_now=`date +%s`
	wait_modem=`expr $MODEM_SHUTDOWN_READY - $time_now`
	if [ $wait_modem -gt 0 ] ; then
		sleep $wait_modem
	fi

echo "Getting modem status"
	MODEM_STATUS=`$CELL_COMS $MODEM_DEV status 2>&1`
echo "Modem status: $MODEM_STATUS"
	# kill pppd if there is a problem talking to the modem
	if [ $? -ne 0 ] ; then
		ppp_down
		MODEM_STATUS=`$CELL_COMS $MODEM_DEV status 2>&1`
	fi
	# Give up if there is still a problem talking to the modem
	if [ $? -ne 0 ] ; then
		return 1
	fi
	
	SIG_BARS_STATUS=`expr "$MODEM_STATUS" : '.*(\(.\)/5).*'`
	SIG_STATUS=`expr "$MODEM_STATUS" : '\(.*\) dBm.*'`
	SIM_STATUS=`expr "$MODEM_STATUS" : '.*SIM: \([^ ]*\)'`
	if [ -z "$SMS_STATUS" ] ; then
		SMS_STATUS=`expr "$MODEM_STATUS" : '.*SMS: \([^ ]*\)'`
	fi
	return 0
}

reboot_modem ()
{

	if [ -z "$MODEM_DEV" ] ; then
		IS_PPP_UP=""
		PPP_STATUS="No-Modem Offline"
		return 1
	fi

	ppp_down
	get_modem_status

	MODEM_REBOOTS=`expr $MODEM_REBOOTS + 1`
	MODEM_STATUS=`$CELL_COMS $MODEM_DEV reboot 2>&1`
	if [ $? -eq 0 ] ; then
		SIG_BARS_STATUS=`expr "$MODEM_STATUS" : '.*(\(.\)/5).*'`
		SIG_STATUS=`expr "$MODEM_STATUS" : '\(.*\) dBm.*'`
		SIM_STATUS=`expr "$MODEM_STATUS" : '.*SIM: \([^ ]*\)'`
		if [ -z "$SMS_STATUS" ] ; then
			SMS_STATUS=`expr "$MODEM_STATUS" : '.*SMS: \([^ ]*\)'`
		fi
	fi
}

shutdown_modem ()
{

	if [ -z "$MODEM_DEV" ] ; then
		IS_PPP_UP=""
		PPP_STATUS="No-Modem Offline"
		return 1
	fi
	
	ppp_down
	get_modem_status

	MODEM_REBOOTS=`expr $MODEM_REBOOTS + 1`
	# Do the reboot, checking for error
	modem_shut_err=`$CELL_COMS $MODEM_DEV shutdown >/dev/null`
	if [ $? -ne 0 ] ; then
		MODEM_STATUS=$modem_shut_err
	fi
echo "shutdown Modem status: [$modem_shut_err]"
	MODEM_SHUTDOWN_READY=`date +%s`
	MODEM_SHUTDOWN_READY=`expr $MODEM_SHUTDOWN_READY + 28`
}



ppp_up ()
{

	if [ -z "$MODEM_DEV" ] ; then
		IS_PPP_UP=""
		PPP_STATUS="No-Modem Offline"
		return 1
	fi

# This is only called if ethernet is down or offline (IS_ETH_UP = "") and ppp is down.
# This checks the modem, and if there is reception and a SIM, it will bring ppp up then check its WAN.
# if pppd fails for MAX_CALL_RETRIES, the modem will be rebooted

# Check the modem status.  This will exit with error if pppd is running and we can't interrupt data mode
	ppp_down
	get_modem_status

# Before calling pppd, we need cellular reception (SIG_STATUS != No), and SIM_STATUS = OK
	if [ "$SIG_STATUS" = "No" -o "$SIM_STATUS" != "OK" ] ; then
		PPP_ADDRESS=""
		return 1
	fi

# pppd will not set a default route if one exists
# The default route is invalid if it exists, since calling this means we have no WAN over eth0.
# The default route may be set to a router that cannot reach the WAN.  In this case, there will
# still be a route for traffic to/from the router.
	/sbin/route del default eth0 >/dev/null 2>&1
# resolv.conf is invalid if it does exist.  If ethernet is up, it can't reach the WAN
	rm /etc/resolv.cof >/dev/null 2>&1
# use flock on the network lock file to avoid contention with cell-modem	
#	/usr/bin/flock $NETLOCK -c /etc/ppp/ppp-on >/dev/null 2>&1
# Commented out because we're making the call from here
# The peer should be configured with nopersist (default) to fail immediately or go to background
	while [ $MODEM_REBOOTS -le $MAX_REBOOT_RETRIES -a -z "$PPP_ADDRESS" ] ; do
		call_retries=$MAX_CALL_RETRIES
		while [ $call_retries -gt 0 ] ; do
echo "calling pppd"
			/usr/sbin/pppd call embeddedworks
			# Check for a background pppd process
			usleep 100000
			pppd_pid=`pidof pppd`
			PPP_ADDRESS=""
			nRetries=20
echo "Getting pppd PID: $pppd_pid, nRetries: $nRetries"
			while [ -z "$pppd_pid" -a $nRetries -ge 0 ] ; do
echo "Getting pppd PID: $pppd_pid, nRetries: $nRetries"
				pppd_pid=`pidof pppd`
				nRetries=`expr $nRetries - 1`
			done
			
			nRetries=20
			while [ -n "$pppd_pid" -a -z "$PPP_ADDRESS" -a $nRetries -ge 0 ] ; do
				sleep 1
				pppd_pid=`pidof pppd`
				PPP_ADDRESS=`ifconfig ppp0 2>/dev/null | grep 'inet addr' | cut -d ':' -f 2 | cut -d ' ' -f 1`
				nRetries=`expr $nRetries - 1`
echo "pppd PID: $pppd_pid, PPP_ADDRESS: $PPP_ADDRESS, nRetries: $nRetries"
			done
			# If there's both a pid and an interface, we're done
			if [ -n "$pppd_pid" -a -n "$PPP_ADDRESS" -a -e '/etc/ppp/resolv.conf' ] ; then
				mv /etc/ppp/resolv.conf /etc/resolv.conf
				check_ppp0_up
echo "pppd is running on $PPP_ADDRESS. After check_ppp0_up status=$PPP_STATUS"
			fi
				
			if [ $IS_PPP_UP ] ; then
				call_retries=0
			else
echo "call retries: $call_retries"
				call_retries=`expr $call_retries - 1`
				ppp_down
				PPP_ADDRESS=""
			fi


		done # call retries
		if [ -z "$PPP_ADDRESS" ] ; then
echo "ppp0 down, rebooting modem"
			reboot_modem
		fi
	done # reboot retries

	if [ -z "$PPP_ADDRESS" ] ; then
		return 1
	fi

	echo "started up ppp"
	return 0
}

check_eth0_up () 
{
	check_iface_up eth0 1
	IS_ETH_UP=$IS_IFACE_UP
	ETH_STATUS=$IFACE_STATUS
}

check_ppp0_up () 
{
	if [ -n "$MODEM_DEV" ] ; then
		check_iface_up ppp0 2
		IS_PPP_UP=$IS_IFACE_UP
		PPP_STATUS=$IFACE_STATUS
		if [ ! $IS_PPP_UP ] ; then
			get_modem_status
		fi
	else
		IS_PPP_UP=""
		PPP_STATUS="No-Modem Offline"
	fi
}


write_status ()
{
echo "vvvvvv STATUS vvvvvvv"
	iface_up=`expr "$ETH_STATUS" : '[^ ]*[ ]*\(Up\).*'`
	if [ -n "$iface_up" ] ; then
		NET_STATUS="ethernet"
	else
		iface_up=`expr "$PPP_STATUS" : '[^ ]*[ ]*\(Up\).*'`
		if [ -n "$iface_up" ] ; then
			NET_STATUS="cellular"
		else
			NET_STATUS="offline"
		fi
	fi
	echo "$NET_STATUS" > $NETLOCK
	echo "$NET_STATUS"
	echo "$ETH_STATUS" >> $NETLOCK
	echo "$ETH_STATUS"
	echo -n "$PPP_STATUS" >> $NETLOCK
	echo -n "$PPP_STATUS"
	if [ -n "$MODEM_STATUS" ] ; then
		echo -n " $MODEM_STATUS" >> $NETLOCK
		echo -n " $MODEM_STATUS"
	else
		if [ -n "$OLD_MODEM_STATUS" ] ; then
			echo -n " $OLD_MODEM_STATUS" >> $NETLOCK
			echo -n " $OLD_MODEM_STATUS"
		fi
	fi
	echo "" >> $NETLOCK
	echo ""
echo "^^^^^^^ STATUS ^^^^^^^"
}


check_network ()
{
	check_eth0_up
	if [ $IS_ETH_UP ] ; then
		ppp_down
		get_modem_status
		NET_STATUS="ethernet"
	else
		check_ppp0_up
		if [ $IS_PPP_UP ] ; then
			NET_STATUS="cellular"
		else
			NET_STATUS="offline"
		fi
	fi
}

start_network ()
{
	check_network
	if [ -z "$IS_ETH_UP" -a -z "$IS_PPP_UP" ] ; then
		ppp_down
		get_modem_status
		eth0_up
		if [ ! $IS_ETH_UP ] ; then
			ppp_up
		fi
	fi
}

stop_network ()
{
	ppp_down
	get_modem_status
	eth0_down
}

run_command ()
{

	case "$1" in
		check)
			check_network
			write_status
			;;
	
		stop)
			stop_network
			shutdown_modem
			write_status
			;;
	
		start)
			start_network
			write_status
			;;
	
		restart)
			stop_network
			shutdown_modem
			start_network
			write_status
			;;
	
		idle)
			stop_network
			write_status
			;;
	
		ppp)
			ppp_down
			ppp_up
			eth0_up
			write_status
			;;
	
		*)
			echo "usage: check|stop|start|restart|idle"
			echo "  restart results in modem reboot (~30 sec.) without ethernet"
			echo "  stop returns immediately after modem shutdown regardless of ethernet"
			echo "  idle disconnects modem from ppp, shuts down dhcp, but leaves ethernet as configured"
			;;
	
	esac
	
}

# start network:
# Check eth0
#   udhcpc may have acquired a lease while we were sleeping
#     If it was able to reach WAN IPs,
#       then it left the only default route as the eth0 route
#       and rewrote resolv.conf.
#     If no WAN IPs, then it left the default route and resolv.conf alone
#   if up, ppp_down()
#     This needs to assertively bring the ppp interface down so we can check the cell status.
#     If we can't obtain the cell status, we have to reboot the modem.
# else
#   Check ppp0
#   if down, ppp_up
#   We have to check the modem status before attempting ppp.  This may require a modem reboot.
# ppp_up:
# connect, connect, connect, reboot, etc.
#   3 retries:
#     3 retries:
#       ppp-on - nopersist in pppd config - exit immediately on failure
#       while pidof pppd and !iface ppp0 (sleep 1; pidof pppd ; iface ppp0 )
#
#     if ! check_modem (SIM status, SMS messages, signal strngth)
#       reboot_modem (factory settings, reboot)
##   

# Get previous status

touch $NETLOCK
# open the netlock file with FD 8 for reading
exec 8< $NETLOCK
read NET_STATUS <&8
read ETH_STATUS <&8
read PPP_STATUS <&8
echo "Previous eth0: $ETH_STATUS"
echo "Previous ppp0: $PPP_STATUS"
# close the netlock file
exec 8>&-
# Extract the old modem status
OLD_MODEM_STATUS=`expr "$PPP_STATUS" : '[^ ]*[ ]*[^ ]*[ ]*\(.*\)'`
PPP_STATUS=""

# open the netlock file with FD 8 for reading/writing
exec 8<> $NETLOCK

# Get a lock for this FD
flock -x -w 10 8

# If we got the lock, run the command
if [ $? -eq 0 ]; then
	got_flock=1
	run_command $1
fi    

# Unlock the FD if we got a lock
if [ $got_flock ]; then
	flock -u 8
	exec 8>&-
	exit 0
else
	echo "ERROR: Unable to acquire network lock."
	exec 8>&-
	exit 1
fi

